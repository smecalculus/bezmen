= Конвейер

== Ключевые принципы

Сущности первого класса::
Решение (solution) - система, реализуемая для клиентов. Конвейер (pipeline) - система, реализуемая для внедренцев. Инструментарий (toolchain) - система, реализуемая для разработчиков.

Единый инструментарий для локальной разработки и непрерывной интеграции::
Семантика интерфейса подразумевает набор предопределенных абстракций, артефакты которых последовательно конструируются в ходе сборки. Перед началом конструирования выполняются обязательные проверки. Примеры абстракций: кодовая база (codebase), бинарники (binaries), образы (images), стеки (stacks) и другие.

Контентная адресация (aka идентификация по содержимому)::
Контентная адресация (content addressability) делает конструирование *идемпотентным*. Для директорий с исходным кодом вычисляются их контентные идентификаторы (CID's). Затем вычисляются корневые идентификаторы решения и конвейера. Таким образом формируется 2 небольших дерева Меркла, хеши которых подставляются в качестве тегов/классификаторов артефактов соответствующих абстракций. Артефакт конструируется, только когда его контентный идентификатор меняется.

Множественность окружений и назначений::
Решение/инструментарий используется клиентами/разработчиками в разных окружениях (envs) для разных назначений (usages). Ключевые окружения/назначения именуются и проверяются в рамках непрерывной интеграции. Устаревшие окружения/назначения снимаются с поддержки.

Тесты! Тесты! Тесты!::
Тестирование - один из самых важных (или даже самый важный) аспектов разработки! При тестировании проверяется поведение целевого объекта в различных ситуациях. В зависимости от подхода к подготовке зависимостей целевого объекта тесты можно подразделить на 3 категории.
Модульные тесты (unit tests):::
Все зависимости целевого объекта глушатся (stub) или мокируются (mock).
Интеграционные тесты (integration tests):::
Все зависимости глушатся/мокируются кроме одной (иногда нескольких), которая честно конструируется.
Сквозные тесты (end-to-end tests):::
Все зависимости честно конструируются.

Роботизированная асинхронная заливка (merge)::
Позволяет избежать ошибок/конкуренции и, как следствие, неоправданных потерь на загруженных ветках (например, main).

== Непрерывная интеграция (CI)

Планы делим на 2 категории:

. Проверяющие решение (solution)
. Проверяющие инструментарий (toolchain)

=== Проверка решения

Решение проверяем во всех окружениях, в которых его могут эксплуатировать клиенты.

==== В пределах разумного (sanity)

Запускаем анализ зависимостей, линтинг, статический анализ, компиляцию, модульные тесты, собираем и публикуем бинарники.

==== Убедительная (convincing)

Все перечисленное ранее. Плюс запускаем интеграционные тесты, анализируем покрытие, собираем и публикуем образы.

==== За пределами сомнений (beyond doubt)

Все перечисленное ранее. Плюс запускаем сквозные тесты, собираем и публикуем стеки.

=== Проверка инструментария

Инструментарий проверяем во всех окружениях, в которых его могут эксплуатировать разработчики.

==== В пределах разумного (sanity)

Запускаем линтинг исходного кода инструментария.

==== За пределами сомнений (beyond doubt)

Запускаем проверку работы всего инструментария.

== Частые вопросы (FAQ)

[qanda]
Почему обязательными статусными проверками назначены тестовые отчеты, а не тестовые джобы?::
Это дает свободу выбора структуры джобов, т.к. в различных планах сборки она может быть разной.

== Консольный интерфейс (CLI)

    ansible-playbook <abstraction>.yml

== Todo

. Релизная сборка
. Параллелизация модульных тестов
. Построение дерева хешей (взглянуть критически)
. Поддержка нескольких версий Java
